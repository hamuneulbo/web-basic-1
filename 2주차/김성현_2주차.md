# 모던 자바스크립트 정리

자바스크립트는 웹브라우저에서 사용하기 위해 만들어진 프로그래밍 언어이다. 따라서 언제나 브라우저에서 사용할 수 있고 크롬의 개발자 도구에서 콘솔로 사용할 수 있다. 예를 들어 개발자 도구의 콘솔 창에서 다음과 같은 코드를 친다.

```js
console.log("안녕하세요");
```

그러면 바로 아래 줄에 안녕하세요 라는 텍스트가 출력되는 것을 볼 수 있다.

## 1장. 자바스크립트 입문

### 변수와 상수

다른 언어에서 그랬던 것과 같이 우리는 JS에서도 변수와 상수를 사용할 수 있다. 변수와 상수는 특정 이름에 값을 담을 때 사용한다. 

원래 자바스크립트에서는 `var` 키워드를 사용했지만 ECMA6부터는 `let` 과 `const` 키워드를 사용하여 변수를 사용한다. `var` 키워드는 없는 것처럼 생각해도 좋다. 변수는 다음과 같이 선언한다.

```js
let a=1;
```

이렇게 하면 a라는 변수를 선언하고 거기 1을 대입하게 된다. 위의 출력 함수 `console.log` 를 사용해서 확인해 볼 수 있다. 단 하나의 변수에 여러 번 값을 대입할 수는 있지만 같은 변수명을 중복 선언할 수는 없다. 

```js
let a=1;
let a=2;
```

위와 같은 중복 선언은 에러를 발생시킨다.

상수는 const 키워드로 선언하는데, 상수는 한 번 선언하면 값을 바꿀 수 없다. 또한 처음 선언할 때 무조건 값을 할당해 주어야 하는 규칙이 있다. `const a;` 와 같이 값을 대입하지 않는 단순 선언은 불가능하다.

- 변수의 타입

변수는 여러 가지 타입의 변수가 존재한다. 단순한 숫자형, 그리고 큰따옴표나 작은따옴표로 감싸는 문자열(단 둘 중 하나만 택해서 일관적으로 사용하는 것이 좋은 코드 작성법이다), true, false 2가지 값밖에 없는 boolean 형이 있다. 그리고 없다는 것을 의미하는 null, undefined가 있다.

이때 null은 변수의 값이 없다는 것을, undefined는 아직 변수값이 설정되지 않았다는 것을 의미한다. 예를 들어 변수를 선언한 후 아무 값도 대입시켜주지 않은 상태에서 출력시 undefined가 출력된다.

### 연산자

JS는 기본적인 사칙연산과 전위 연산자, 후위 연산자, 복합 대입 연산자를 지원한다. 예를 들어 다음과 같다.

```js
let a=2*10-3;
console.log(a);
//결과는 17
a++;
console.log(a);
//결과 18
a+=100;
console.log(a);
//결과는 118
```

그리고 NOT 연산자 `!`, AND 연산자 `&&`, OR 연산자 `||` 가 있다. C언어 등의 언어와 매우 비슷하다. 이때 AND와 OR 도 연산자이므로, 연산 결과를 반환해야 한다. AND와 OR는 그 연산이 끝나게 만든 마지막 시점의 피연산자를 반환한다. 만약 AND 연산이라면, False로 판정되는 값이 나왔을 때 더 이상 연산을 진행할 필요가 없을 것이다. 따라서 처음 나온 False 판정값을 반환한다. OR연산은 True 판정 값이 하나라도 있으면 True이다. 따라서 피연산자 중 처음 나오는 True로 판정되는 값을 반환한다. 만약 그런 게 없을 시 마지막 값을 반환한다.

```js
let a=10, b=3, c=0;
console.log(a && b && c);
//결과 0
console.log(a || b || c);
//결과 10
```

이때 c가 0이므로 a && b && c는 False가 된다. 그 원인이 된 c의 값을 반환하여 첫째 출력은 0이 된다. a || b || c가 True로 판정되는 이유는 a가 10이기 때문이므로 그 첫 원인이 되는 a를 반환해 주어 10이 출력되는 것이다.

논리 연산자의 순서는 NOT -> AND -> OR 순이다. 헷갈리기 쉬우므로 가독성을 위해선 괄호를 써서 우선순위를 정해주는 게 좋다.

비교 연산자 `<, >, <=, >=, ==, ===, !=, !==` 도 지원한다. 이때 `===` 과 `==`의 차이는, `==` 는 비교 시 타입 검사를 하지 않는다는 것이다. `!=` 와 `!==` 도 마찬가지다. 따라서 제대로 된 비교를 위해서는 `===, !==` 를 사용해 주는 것이 좋다. 예를 들어 `==` 는 `1=='1'` 을 참으로 판정한다. 둘이 다른 타입이라는 것을 검사하지 않기 때문이다.

주석은 C언어와 같이 `//, /* */` 를 사용한다.

그리고 문자열도 더하기(concatenation)가 가능하다.

### 조건문

if문은 C언어의 if문과 같다. 만약 if 문 내부의 조건이 참이 되면 중괄호 안의 문이 실행된다. if~else if~else 문도 C언어와 같다. switch문도 같다. 단 모든 case가 참이 아닐 때 실행하는 default 조건을 달 수 있는 것이 차이이다.

### 함수

함수는 특정 코드를 반복적으로 실행할 때, 하나의 명령으로 실행하게 해준다. function 키워드를 이용해 선언한다. 두 파라미터를 받아서 합을 구해주는 함수는 다음과 같다.

```js
function add(a,b){
  return a+b;
}
console.log(add(30,57));
//결과 87
```

또는 화살표 함수라고 하는, JS에서 함수를 더 간편하게 선언할 수 있는 방법도 있다. 다음과 같은 코드를 작성하면 위의 함수와 똑같은 동작의 함수를 작성할 수 있다.

```js
const add=(a,b)=>{
    return a+b;
  }
```

이렇게 하면 화살표 함수로 익명 함수를 선언한 후 add라는 이름에 이를 대입한다. 이때 화살표 함수와 function 키워드를 이용해 선언한 함수의 차이가 아예 없는 것은 아니다. this 키워드가 가리키는 대상이 다르다. 이는 나중에 더 알아보도록 한다.

그리고 함수의 파라미터에는 기본값을 지정할 수 있다. `func(param=1)` 과 같이 파라미터를 선언할 때 값을 대입해 주면 그것이 파라미터의 기본값이 되어서 파라미터에 값을 넣지 않으면 자동으로 기본값이 대입된다.

### 템플릿 리터럴

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals

작은 따옴표나 큰따옴표 대신 백틱(\`) 을 사용하는 문자열이다. 이러한 템플릿 리터럴은 `$`와 중괄호를 사용해 표현식을 넣을 수 있다. 이를 플레이스홀더라 하고, 플레이스홀더 내부의 표현식과 텍스트는 함께 함수로 전달되어 단일 문자열로 연결된다. 다음과 같이 플레이스홀더 내부에 표현식을 쓸 수 있다.

```js
const add=(a,b)=>{
return a+b;
}
console.log(`print the result ${add(3,5)}`);
```

### 객체

객체는 하나의 이름에 여러 종류의 값을 넣을 수 있게 해주는 수단이다. key와 value 쌍으로 이루어진다. 중괄호 내부에 원하는 이름과 값들을 넣어 주면 된다.

```js
let parents={    mother:"엄마",    father:"아빠"  }console.log(parents);
```

또한 객체 내부 변수에 접근할 수도 있다. 예를 들어 위의 객체에서 객체 내부의 mother에 접근하는 예시이다.

```js
let parents={
    mother:"엄마",
    father:"아빠"
  }
  console.log(parents.mother);
```

`엄마` 가 결과로 출력되는 것을 확인할 수 있다. 그리고 키에 해당하는 부분에는 공백이 없어야 한다. 만약 공백이 있어야 한다면 이를 따옴표로 감싸 문자열로 넣어준다.

### 비구조화 할당

객체에서 값들을 추출하여 새로운 변수에 대입할 수도 있다. 예를 들어서 다음과 같이 하면 parents 객체에서 내부의 key 에 따라서 value들을 매칭해서 각각에 담아준다.

```js
let parents={
    mother:"엄마",
    father:"아빠"
  }
  const{mother,father}=parents;
  console.log(mother,father);
```

함수에서 파라미터를 받을 때 비구조화 할당을 할 수도 있다.

```js
const study={
      name1:"김성현",
      name2:"김창민",
    };
    
    function print({name1, name2}){
      console.log(`스터디원 하나는 ${name1}이고 또 하나는 ${name2}입니다.`);
    }

    print(study);
```

이때 만약 객체에 없는 key로 비구조화 할당을 하게 되면 그 변수에는 undefined가 저장되게 된다. 위의 구조체를 다음과 같이 할당하고 출력해 본다.

```js
const study={
  name1:"김성현",
  name2:"김창민",
};

const {name1, c}=study;

console.log(name1, c);
//김성현 undefined가 출력된다
```

객체 안에 함수를 넣을 수도 있다.

```js
const study={
  name1:"김성현",
  say:function (){
    console.log(this.name1);
  }
};

study.say();
//김성현 이 출력된다.
```

이때 화살표 함수는 this가 다른 것으로 할당되기 때문에 객체 안의 함수는 function키워드를 사용해야 위와 같이 쓸 수 있다.

https://mygumi.tistory.com/161

그리고 get, set 키워드를 이용해서 getter와 setter 함수를 만들 수 있다. 이는 객체지향의 은닉 개념과도 연관이 있다. 그리고 get,set 함수를 사용할 때의 이점은, 어떤 변수를 불러오거나 값을 설정할 때 조건을 줘야 할 때가 있을 때 실질적인 의미가 생기기도 한다. 어떤 변수값을 설정하는데 값이 10 이상일 때만 변수값을 실제로 대입해야 할 때가 있을 수 있다. 이럴 때 물론 if문을 사용해서 변수값을 먼저 검사한 후 넣을 수 도 있을 것이다. 그런데 다음과 같이 하면 훨씬 더 직관적이고 일반적인 코드를 짤 수 있다.

```js
const numbers={
  _a:1,
  _b:2,
  get a(){
    return this._a;
  },
  set a(val){
    if(val>=10){
      this._a=val;
    }
  }
}

console.log(numbers.a);
numbers.a=5;
console.log(numbers.a);
numbers.a=11;
console.log(numbers.a);
```

a에 5를 대입하면, 10 이상인 값만 대입한다는 setter 함수의 검사 때문에 대입되지 않는 것을 볼 수 있다.

### 배열

자바스크립트 배열은 여러 개의 항목이 들어 있는 리스트와 같다. 배열 안에는 어떤 값이든 넣을 수 있고, 인덱스를 통해 조회할 수 있다. 이때 배열에는 서로 다른 타입끼리도 들어갈 수 있다.

```js
const temp=[1,2,{name:"김성현"}];

console.log(temp[1]);
console.log(temp[2]);
//인덱스를 통해 정상적으로 조회된다
```

`arr.push(item);` 과 같이, push 함수로 배열에 새로운 항목을 추가할 수 있다. 또한 배열은 length 값을 가지는데, 이것으로 배열의 길이를 조회할 수 있다. `arr.length`(함수가 아니라서 () 가 붙지 않음에 주의한다.)

### 반복문

자바스크립트에서도 C언어와 같은 for 반복문을 사용할 수 있다. 단 변수 선언 키워드가 int등이 아니라 let임에 주의하자.

```javascript
for (let i = 0; i < names.length; i++) {
  console.log(names[i]);
}
```

while도 C언어와 마찬가지로 조건문이 false가 될 때까지 반복하는 반복문으로 쓰인다.

for..of 반복문은 배열의 원소들을 순회하기 위해서 사용된다. 다음과 같이 배열의 원소들을 하나하나 임시 변수에 넣어가며 순회할 수 있다. 그러나 배열의 순회에는 보통 배열 내장 함수가 사용되므로 실제로 for..of를 쓰는 일은 별로 없다. 

```js
let members=["권지은", "김성현", "김창민", "김하늘", "이소연"];
for(let member of members){
  console.log(member);
}
```

객체를 위한 반복문으로는 for..in 반복문이 있다. 객체의 key들을 하나씩 순회할 수 있다.

```js
let info={
  name:"김성현",
  nation:"대한민국",
  age:25
};
for (let key in info){
  console.log(key, info[key]);
}
```

또한 반복문을 사용하는 대신, 객체의 정보를 배열 형태로 받아올 수 있는 함수들도 있다.

```js
let info={
  name:"김성현",
  nation:"대한민국",
  age:25
};
console.log(Object.entries(info));
//[키, 값] 쌍이 담긴 배열들의 배열을 반환
console.log(Object.keys(info));
//key들이 담긴 배열 반환
console.log(Object.values(info));
//value들이 담긴 배열 반환
```

또한 실행되던 반복문 루프를 종료시키고 빠져나갈 땐 `break`, 루프의 그 다음 순서로 바로 넘어가게 하려면 `continue`를 사용한다. C언어와 같은 키워드이다.

이러한 반복문을 이용하여, 배열을 파라미터로 받은 후 그 배열의 원소 중 3보다 큰 원소만 담은 새로운 배열을 리턴하는 함수를 짤 수 있다.

```js
function biggerThanThree(numbers) {
  let arr=[]
  for(let i of numbers){
    if(i>3){
      arr.push(i);
    }
  }
  return arr;
}
```

### 배열 내장 함수

forEach는 for문을 대체하여 배열의 원소를 하나씩 순회할 수 있다. forEach의 파라미터로는 각 원소에 대하여 처리하고 싶은 함수를 넣어 준다. 그러면 배열의 원소 하나하나는 자동으로 함수의 파라미터로 들어가서 함수를 실행시킨다.

```js
const numbers=[1,2,3,4,5,5,7];

numbers.forEach(n=>{
  console.log(n);
})
```

map은 배열 안의 모든 원소들에 어떤 함수를 적용한 결과물로 새로운 배열을 얻고 싶을 때 사용된다. 가령 배열의 원소 중 짝수인 것만 제곱한 상태의 새로운 배열을 얻고 싶다고 하면 map 함수로 다음과 같이 작성할 수 있다.

```js
const numbers=[1,2,3,4,5,6,7];

const result=numbers.map(n=>{
    if(n%2===0){
        return n*n;
    }
    else return n;
})
console.log(result);
```

이렇게 하면 `numbers` 배열의 원소 중 짝수인 원소만 제곱한 새로운 배열이 만들어짐을 출력 결과로 확인 가능하다.

`indexOf` 는 배열에서 원하는 항목이 몇 번째 인덱스에 있는지 찾아서 그 인덱스를 반환해 준다. `arr.indexOf(1)` 등으로 사용한다. 배열의 인덱스는 0부터 시작함에 유의하자.

```js
const numbers=[1,2,3,4,5,6,7];
console.log(numbers.indexOf(3));
//결과는 2
```

만약 `indexOf` 함수가 찾는 원소가 배열에 없다면 함수는 `-1`을 반환한다. 이때 indexOf 함수의 약점은, 숫자, 문자열, 불리언 값만 찾을 수 있다는 것이다. 배열 내에 있는 객체나 배열을 찾을 땐 사용할 수 없다. 이럴 때는 `findIndex` 함수에, 검사하고자 하는 조건을 반환하는 함수를 넣어 찾을 수 있다. 함수가 파라미터로 들어감에 유의하자.

```js
todos.findIndex(todo => todo.id === 3);
```

위와 같이 사용한다. 저러면 todos의 원소들 중 id key가 3인 원소의 인덱스를 반환한다. 비슷하지만 찾아낸 원소의 인덱스 대신 찾아낸 원소 그 자체를 반환하는 `find` 함수가 있다.

`filter` 함수는 배열의 각 원소를 검사하여 특정 조건을 만족하는 값들만 따로 추린 후 새로운 배열을 만들어 반환해 준다. 예를 들어 음식들과 그 가격을 표시한 객체들이 들어 있는 배열에서, 6000원 이상의 메뉴만 뽑는 등의 상황을 생각한다. 그러면 filter를 이용해 다음과 같은 코드를 작성할 수 있다.

```js
const foods=[
  {
    name:"짜장면",
    price:5000
  },
  {
    name:"짬뽕",
    price:6000
  },
  {
    name:"볶음밥",
    price:7000
  },
];

console.log(foods.filter(food=>food.price>=6000));
```

filter 함수의 파라미터로는 조건을 검사하는 함수를 넣어주고, filter 함수는 그 함수가 true를 반환하는 원소들을 모아 새로운 배열을 만들어 리턴한다.

`splice` 는 배열에서 항목을 제거할 때 쓴다. 첫번째 파라미터는 몇번째 인덱스부터 제거할지, 두번째 파라미터는 몇 개나 제거할지를 의미한다.

`slice` 는 배열의 특정 부분을 잘라내서 새로운 배열을 리턴한다. `arr.slice(i,j)` 는 arr 배열의 i번째 인덱스부터 j번째 인덱스 바로 전까지 잘라낸다. j번째 인덱스는 포함되지 않음에 주의한다.

`shift` 는 배열의 맨 첫 원소를 추출한 후 제거하고(pop_front같은 것), `pop`은 맨 뒤 원소를 추출한 후 제거한다. 

`unshift` 는 배열의 맨 앞에 새 원소를 추가한다. `push_front` 와 비슷한 기능을 한다.

`concat`은 여러 배열을 하나로 합쳐준다. `arr1.concat(arr2)` 는 arr1과 arr2를 이어서 하나의 배열로 만든 후 리턴해 준다.

`join`은 배열을 문자열 형태로 합쳐준다. 파라미터로 준 문자열을 배열의 원소 사이사이에 넣어 구분해준다.

`reduce` 는 배열의 원소들에 순차적으로 함수를 적용해 가며 누적된 최종 값을 리턴한다. 

### 프로토타입과 클래스

객체 생성자에 대해 먼저 본다. 객체 생성자는 함수를 통해 새로운 객체를 만들고 그 내부에 넣고 싶은 값이나 함수들을 구현할 수 있게 한다. 이렇게 하면 특정 함수 또는 값을 재사용할 수 있다는 이점이 있다. 

생성자 함수를 사용하면 다른 객체지향 언어의 class와 같이 껍데기를 만들 수 있다.

이때 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작하게 된다. 그래도 일반 함수와 구분하기 위해, 생성자 함수는 대문자로 시작하도록 작명하는 것이 관례이다.

```js
function Person(name, age){
  this.name=name;
  this.age=age;
  this.info=function(){
    console.log(`이름은 ${this.name}이고 나이는 ${this.age}살입니다.`);
  }
}

const me=new Person("김성현", 25);
me.info();
```

위에서 Person 이라는 객체의 껍데기를 만들어 준 것을 알 수 있고, new 키워드를 이용하면 껍데기에 내용물을 넣어서 객체를 만들어 줄 수 있다.

프로토타입은 객체 생성자 함수의 메서드처럼 사용할 수 있다. 가령 `Person.prototype.say` 와 같이 하고 거기에 무언가 대입해서 상속에 사용할 수 있다.

### 클래스

ECMA6에서는 이러한 프로토타입 기반의 객체지향을 대신할 클래스가 도입되었다. 우리가 객체 생성자로 구현했던 코드를 좀더 깔끔하게 구현하고 상속할 수 있게 해준다.

생성자를 위해서 `constructor` 키워드를 사용한다. 또한 클래스 내부에 함수를 선언하면 메서드가 되고 자동으로 prototype 으로 등록되게 된다.

그리고 `extends` 키워드를 사용해서 쉽게 상속할 수 있다. 만약 Person 클래스를 상속하여 `Man` 클래스를 만들고 싶다면 `class Man extends Person` 과 같이 쓴다. 그리고 상속받은 클래스의 생성자를 가리키기 위해 `super()` 를 사용한다. Food 클래스로 만든 예시는 다음과 같다. 상속과 생성자, super를 사용하였다.

```js
class Food{
  constructor (brand) {
    this.brand=brand;
  }
}

class Pizza extends Food{
  constructor (brand, topping) {
    super(brand);
    this.topping=topping;
  }
  print(){
    console.log(`${this.brand}에서 나온 피자고 ${this.topping}이 올라가 있다`);
  }

}
const pizza=new Pizza("도미노피자", "페퍼로니");
pizza.print();
```

# 2장. 유용한 자바스크립트 문법

### 삼항 연산자

JS에서도 삼항 연산자를 사용할 수 있다. 다만 가독성이 떨어질 수 있으므로 적절히 사용해야 한다.

### truthy/falsy

if문의 참 거짓 판정 등에서, true 같은 값과 false 같은 값이 어느 것인지는 중요하다. `undefined, null,  0, 빈 문자열, Nan` 을 제외하면 모두 truthy 값이다.

### 단축 평가

위에서 다루었던, &&나 ||가 그 연산을 false로 만드는 첫 값을 반환하는 것을 이용해 코드를 단축시킬 수 있다.

