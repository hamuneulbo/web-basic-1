# JavaScript

## 1. 입문

* `console.log('Hello World!')`: 콘솔에 내용 출력
* ```console.log(`My name is $(name변수)`)```: 콘솔 출력 문자열에 변수 대신 사용
* `let`: 변수 선언
* `const`: 상수 선언
* `===`: 같은지 확인
  * `==`: 타입 검사하지 않음. eg) 0 = false, undefined = null, 1 = '1'

나머지 논리,비교 연산자는 c++과 겹치므로 생략

### 1-1. 함수 선언

#### function 함수

```JavaScript
function add(a,b){
    return a+b;
}

const sum = add(1,2); // 3
```

#### 화살표 함수

```JavaScript
const add = (a,b) => {
    return a+b;
};

const add = (a,b)=> a+b;
```

### 1-2. 객체

#### 객체 선언

```JavaScript
const dog = { // 키:값
    name: '개',
    age: 2,
    'key with space': true 
    // 키에 공백이 있으면 따옴표로 감쌈
    say: function(){ // 화살표 함수 불가능
        console.log(this.name);
    // this: 함수가 들어있는 객체
    }
};

console.log(dog.name);
dog.say();
```

#### 객체 안 getter, setter 함수

```JavaScript
const numbers = {
    _a: 1,
    _b: 2,

    // getter 함수: 객체 안 특정 값 조회시 설정된 함수로 연산된 값 반환
    get sum(){ return this._a+this._b;},

    // setter 함수: 객체 안 특정 값 변환시 함수 수행
    set a(value){ this._a = value;}
};

console.log(numbers.sum); // getter 함수 실행
numbers.a = 10; // setter 함수 실행
```

#### 객체 구조 분해 / 비구조화 할당

```JavaScript
const IronMan = {
    name: 'Tony',
    actor: 'Ro'
}

const {name, actor} = IronMan;

function print({name, actor = '*'}){ 
    // actor 값이 주어지지 않았을 때 기본값을 '*'으로 설정
}
print(IronMan);

// IronMan 객체 안 name을 nickname으로 바꿔 선언
const {name: nickname} = IronMan;

// 배열도 가능
const array = [1,2];
const [one, two] = array;
```

### 1-3. 반복문

```JavaScript
// 기본은 c++랑 같음

// < 배열 반복문 >
for(let obj of objects){}

const IronMan = {
    name: 'Tony',
    actor: 'Ro'
}

// < 객체 정보를 배열 형태로 받아오는 함수>
Object.entries(IronMan); // [ [키,값], [키, 값]]
Object.keys(IronMan); // [키, 키]
Object.values(IronMan); // [값, 값]

// < 객체 반복문 >
for(let key in IronMan){
    // IronMan[key] : 키에 대한 값
}
```

### 1-4. 배열

* 숫자 배열: `const array = [1,2,3];`
* 객체 배열: `const objects = [{name: '야'}, {name: '호'}];`
* 새 항목 추가: `objects.push({name: '~'});`
* 배열 크기: `objects.length`

#### 배열 내장함수

```JavaScript
const array = [1,2,3];

// 1) forEach: 배열의 모든 원소들에 대한 함수
array.forEach(num => {
    console.log(num);
});

// 2) map: 각 원소마다 변화함수 실행
const square = n => n*n; // 변화 함수
const squared = array.map(square); 

const squared = array.map(n => n*n);

// 3) indexOf: 원소의 인덱스 반환. 0부터 시작
console.log(array.indexOf(1));

// 4) findIndex: 객체/배열인 원소의 인덱스 반환.
const objects = [{name: '야'}, {name: '호'}]
objects.findIndex(obj => obj.name === '야'); // 0

// 5) find: 조건을 만족하는 원소 반환
객체.find(조건 콜백 함수);

// 6) filter: 특정 조건 만족하는 값들로 새로운 배열 생성
객체.filter(조건 콜백 함수);

// 7) splice: 특정 항목 제거
array.splice(index, length);
// index: 지우기 시작할 인덱스
// length: 시작 인덱스부터 지울 항목 개수

// 8) slice: splice와 동일. 기존 배열은 바뀌지 않음.
const newArray = array.slice(0,1);

// 9) shift: 첫번째 원소를 배열에서 추출&삭제
const value = array.shift();

// 10) pop: 마지막 원소를 배열에서 추출&삭제
const value = array.pop();

// 11) unshift: 맨 앞에 원소 삽입
array.unshift(5);

// 12) concate: 여러 배열을 하나로 합쳐줌
const newArray = arr1.concate(arr2);

// 13) join: 배열 안 값을 문자열 형태로 합쳐줌
const array = [1,2,3];
array.join('*'); // 1*2*3
// 괄호 안 문자를 원소 사이에 넣음

// 14) reduce
let sum = array.reduce(
    (accumulator, current, index, array) => {
        return accumulator+current;
    }, 0 // accumulator의 초기값
)
// accumulator: 누적값
// current: 현재 항목
// index: 현재 항목의 인덱스
// array: 배열
```

### 1-5. 프로토타입과 클래스

#### `class` 문법

ES6에서부터 사용 가능.

```JavaScript
class Animal {
  constructor(type, name, sound) {
    this.type = type;
    this.name = name;
    this.sound = sound;
  }
  say() { // 메서드: 클래스 내부 함수. 자동으로 프로토타입으로 등록됨.
    console.log(this.sound);
  }
}

const dog = new Animal('개', '멍멍이', '멍멍');
dog.say(); // 멍멍

// Dog class는 Animal class를 상속한다.
class Dog extends Animal {
  constructor(name, sound) {
    super('개', name, sound); 
    // super: 상속받은 클래스의 생성자
  }
}

const dog = new Dog('멍멍이', '멍멍');
dog.say(); // 멍멍
```

#### ES5에서는

프로토타입: 같은 객체 생성자 함수를 사용할 때, 재사용 할 수 있는 특정 함수 또는 값.

```JavaScript
// 객체 생성자
function Animal(type, name, sound) {
  this.type = type;
  this.name = name;
  this.sound = sound;
  /* 
  this.say = function() {
    console.log(this.sound);
  };
  이 함수는 재사용 할 수 있으므로 프로토 타입으로 설정
  */
}

Animal.prototype.say = function(){
    console.log(this.sound);
};

const dog = new Animal('개', '멍멍이', '멍멍');

// Dog가 Animal을 상속함.
function Dog(name, sound) {
  Animal.call(this, '개', name, sound);
}
Dog.prototype = Animal.prototype;
```

## 2. 유용한 문법

* 삼항 연산자는 c++과 동일
* scope: global, funtion, block
* 콜백함수: 함수 타입의 값을 파라미터로 넘겨줘서 파라미터로 받은 함수를 특정 작업이 끝나고 호출함.
* hoisting: 선언 전 함수/변수를 사용함. 되도록 피할 것.
  
### 2-1. Truthy and Falsy

Falsy: undefined, null, 0, '', NaN

!Falsy = true.

> NaN: Not a Number.
>
> 문자열을 숫자로 변환하는 parseInt 함수에서 볼 수 있음.  
> eg) `parseInt('야호~', 10)`: '야호~'를 10진수로 변환하려 함 -> NaN

### 2-2. 단축평가 논리 계산법

#### 함수 파라미터를 전달 안 할 때

```JavaScript
funtion getName(animal){
    if(animal) return animal.name;
    else return undefined;
}

getName(); // undefined 반환
```

#### && 연산자, || 연산자

* A && B  
A가 Truthy -> 결과값: B  
A가 Falsy -> 결과값: A

* A || B  
A가 Truthy -> 결과값: A  
A가 Falsy -> 결과값: B

```JavaScript
function getName(animal){
   const name =  animal && animal.name;
   // animal 파라미터 값 전달받았으면 -> name = animal.name
   // 전달받지 않았으면 -> name = animal(undefined)
   return name || '이름 없는 동물';
}
```

### 2-3. 함수의 기본 패러미터

```JavaScript
function calculateCircleArea(r=1){
    // r 값이 주어지지 않으면 1 사용.
    return Math.PI*r*r;
}
```

### 2-4. 조건문 응용

#### 특정 값이 여러 값 중 하나인지 확인

배열을 만들어서 `includes`함수 사용

```JavaScript
const isAnimal = name => ['고양이', '개', '거북이'].includes(name);
```

#### 값에 따라 다른 결과물 반환

```JavaScript
function getSound(animal){
    const sounds = {
        개: '멍멍',
        고양이: '야옹'
    };

    return sounds[animal] || '...?';
}

// 값에 따라 실행해야 하는 코드 구문이 다를 때
function makeSound(animal){
    const tasks ={
        개(){ },
        고양이() {}
    };

    if(!tasks[animal]) return;
    tasks[animal]();
}
```

### 2-5. spread와 rest 문법

```JavaScript
const num1=[1,2,3];
const num2 = [...num1, 4, 5]; // [1,2,3,4,5]

const [one, ...rest] = num1;
// one: 1
// rest: [2,3]

// [...rest, last] : error

// 함수 파라미터가 몇 개인지 모를 때 배열로 받기
function Sum(...rest){}
Sum(...num1); // Sum(num1[0], num1[2], num1[2])
```
